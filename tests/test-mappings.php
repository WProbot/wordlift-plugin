<?php
/**
 * This file provides the test for the Mappings feature.
 *
 * @since 3.25.0
 * @package Wordlift
 * @subpackage Wordlift/tests
 */

class Wordlift_Mappings_Test extends Wordlift_Unit_Test_Case {

	private $jsonld_service;

	/**
	 * The {@link Wordlift_Mapping_Validator} instance to test.
	 *
	 * @since  3.25.0
	 * @access private
	 * @var \Wordlift_Mapping_Validator $validator The {@link Wordlift_Mapping_Validator} instance to test.
	 */
	private $validator;

	/**
	 * The {@link Wordlift_Mapping_DBO} instance to test.
	 *
	 * @since  3.25.0
	 * @access private
	 * @var \Wordlift_Mapping_DBO $dbo The {@link Wordlift_Mapping_DBO} instance to test.
	 */
	private $dbo;

	function setUp() {
		parent::setUp(); // TODO: Change the autogenerated stub
		// Initialize dependancies for the test.
		$this->dbo       = new Wordlift_Mapping_DBO();
		$this->validator = new Wordlift_Mapping_Validator();

		// Try to get the ACF PRO Key, if not set, skip this test.
		$acf_pro_key = getenv( 'ACF_PRO_KEY' );
		if ( empty( $acf_pro_key ) ) {
			$this->markTestSkipped( '`ACF_PRO_KEY` not set, test skipped.' );
		}

		// Load the WP Filesystem.
		$wp_filesystem = $this->load_wp_filesystem();
		$this->assertNotNull( $wp_filesystem, 'We require a $wp_filesystem.' );

		// Download the ACF PRO package.
		$acf_download_url = "https://connect.advancedcustomfields.com/index.php?a=download&p=pro&k=$acf_pro_key";
		$response         = wp_remote_get( $acf_download_url, array( 'timeout' => 60, ) );

		// Store the zip file to the plugin directory.
		$acf_destination_path = $wp_filesystem->wp_plugins_dir() . '/advanced-custom-fields-pro.zip';

		// Store the data locally.
		$body = wp_remote_retrieve_body( $response );
		$this->assertFalse( is_wp_error( $response ) || ! isset( $response['body'] ), 'An error occurred: ' . var_export( $response, true ) );
		$result_1 = $wp_filesystem->put_contents( $acf_destination_path, $body );
		$this->assertTrue( $result_1, "Unable to save ACF Pro to the local WordPress test install [ class name :: " . get_class( $wp_filesystem ) . " ][ url :: $acf_download_url ][ path :: $acf_destination_path ]." );

		// Unzip the plugin.
		$result_2 = unzip_file( $acf_destination_path, $wp_filesystem->wp_plugins_dir() );
		$this->assertNotWPError( $result_2, 'An error occurred: ' . var_export( $result_2, true ) );

		// Activate the plugin.
		$result_3 = activate_plugin( 'advanced-custom-fields-pro/acf.php' );
		$this->assertNotWPError( $result_3, 'An error occurred: ' . var_export( $result_3, true ) );

		// Add the How To taxonomy term.
		$result_4 = wp_insert_term( 'How To', 'category' );
		$this->assertNotWPError( $result_4, 'An error occurred: ' . var_export( $result_4, true ) );

		$this->jsonld_service = Wordlift_Jsonld_Service::get_instance();
		require( 'test-mappings.acf.php' );
	}

	/**
	 * Get a {@link WP_Filesystem_Direct} instance.
	 *
	 * @return WP_Filesystem_Direct The {@link WP_Filesystem_Direct} instance.
	 */
	private function load_wp_filesystem() {

		// Required for REST API calls
		if ( ! function_exists( 'WP_Filesystem' ) ) {
			require_once( ABSPATH . 'wp-admin/includes/file.php' );
		}

		// Load `WP_Filesystem`, forcing the direct method.
		add_filter( 'filesystem_method', array( $this, '__return_direct' ) );
		WP_Filesystem();
		remove_filter( 'filesystem_method', array( $this, '__return_direct' ) );

		global $wp_filesystem;

		return $wp_filesystem;
	}

	/**
	 * Injects a new rule and create a mapping item.
	 * @param String $taxonomy The taxonomy like category.
	 * @param String $taxonomy_value The value of the taxonomy.
	 * @return void
	 */
	private function create_new_mapping_item( $taxonomy, $taxonomy_value, $properties ) {
		$mapping_id = $this->dbo->insert_mapping_item( 'foo' );
		// Create a rule group.
		$rule_group_id = $this->dbo->insert_rule_group( $mapping_id );

		$rule_id = $this->dbo->insert_or_update_rule_item(
			array(
				'rule_field_one'   => $taxonomy,
				'rule_logic_field' => '===',
				'rule_field_two'   => $taxonomy_value,
				'rule_group_id'    => $rule_group_id,
			)
		);
		foreach ( $properties as $property ) {
			$property['mapping_id'] = $mapping_id;
			$this->dbo->insert_or_update_property( $property );
		}
	}

	/**
	 * Always return `direct`. Useful to force the {@link WP_Filesystem} function to always return a
	 * {@link WP_Filesystem_Direct} instance.
	 *
	 * @return string Always `direct`.
	 */
	public function __return_direct() {

		return 'direct';
	}

	/**
	 * Test all how to mapping
	 */
	public function test_how_to_mapping() {
		$post_id  = $this->factory()->post->create();
		// add to category how to .
		$result_1 = wp_add_object_terms( $post_id, 'how-to', 'category' );
		// create 1 step item.
		$result = add_row( 
			'step', 
			array(
				'type' => 'HowToStep',
				'name'  => "Name",
				'step_item' => array(
					array(
						'step_type' => "HowToDirection",
						'step_text' => "Step Text",
					),
				),
			),
			$post_id
		);

		// Add title for HowTo.
		$title_result = update_field(
			'name',
			'Name',
			$post_id
		);

		// Add Description for HowTo
		update_field(
			'description',
			'foo',
			$post_id
		);

		// Add estimated amount.
		update_field(
			'estimatedCost',
			'100 USD',
			$post_id
		);
		// Create 2 tool items.
		for ( $i = 1; $i <= 2; $i ++ ) {
			$result = add_row( 'tool', array(
				'type' => 'HowToTool',
				'name' => "Tool $i"
			), $post_id );
			$this->assertNotFalse( $result, 'Must not be false.' );
		}
		// Create 2 supply items.
		for ( $i = 1; $i <= 2; $i ++ ) {
			$result = add_row( 'supply', array(
				'type' => 'HowToSupply',
				'name' => "Supply $i"
			), $post_id );
			$this->assertNotFalse( $result, 'Must not be false.' );
		}

		// Before validating json ld add rules and properties.
		$properties = array();
		// Property to make type mapping.
		$property_data_1 = array(
			'property_name' => '@type',
			'field_type' => 'text',
			'field_name'          => 'HowTo',
			'transform_function'  => 'text_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);
		// Property to make step mapping.
		$property_data_2 = array(
			'property_name'   => 'step',
			'field_type' => 'acf',
			'field_name'      => 'step',
			'transform_function'  => 'how_to_step_transform_function',
			'property_status'      => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);
		// Property to make tool mapping.
		$property_data_3 = array(
			'property_name' => 'tool',
			'field_type' => 'acf',
			'field_name'          => 'tool',
			'transform_function'  => 'how_to_tool_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);
		// Property to make supply mapping.
		$property_data_4 = array(
			'property_name' => 'supply',
			'field_type' => 'acf',
			'field_name'          => 'supply',
			'transform_function'  => 'how_to_supply_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);

		// Property to make name mapping.
		$property_data_5 = array(
			'property_name' => 'name',
			'field_type' => 'acf',
			'field_name'          => 'name',
			'transform_function'  => 'text_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);

		$property_data_6 = array(
			'property_name' => '@context',
			'field_type' => 'text',
			'field_name'          => 'http://schema.org',
			'transform_function'  => 'text_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);

		// Description property.
		$property_data_7 = array(
			'property_name' => 'description',
			'field_type' => 'acf',
			'field_name'          => 'description',
			'transform_function'  => 'text_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);

		// Property for estimated amount.
		$property_data_8 = array(
			'property_name' => 'estimatedCost',
			'field_type' => 'acf',
			'field_name'          => 'estimatedCost',
			'transform_function'  => 'text_transform_function',
			'property_status'     => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);

		// collect the properties.
		$properties = array(
			$property_data_1,
			$property_data_2,
			$property_data_3,
			$property_data_4,
			$property_data_5,
			$property_data_6,
			$property_data_7,
			$property_data_8,
		);
		// Create a new mapping with these properties.
		$this->create_new_mapping_item( 'category', (int) $result_1[0], $properties );
		// Get the json-ld mapping.
		$jsonlds = $this->jsonld_service->get_jsonld( false, $post_id );
		$mapping_converter_instance = new Wordlift_Mapping_Jsonld_Converter( $post_id, $jsonlds );
		// After converting get the json ld data and validate.
		$jsonlds = $mapping_converter_instance->get_jsonld_data();
		// The json ld generated by mapping is at the end of the array.
		$how_to_jsonld = end( $jsonlds );
		// Make assertions.
		// Type should be HowToStep.
		$this->assertEquals( 'http://schema.org', $how_to_jsonld['@context'] );
		$this->assertEquals( 'HowTo', $how_to_jsonld['@type'] );
		$this->assertEquals( 'Name', $how_to_jsonld['name'] );
		// Recommended fields (optional).
		$this->assertArrayHasKey( 'description', $how_to_jsonld );
		$this->assertEquals( 'foo', $how_to_jsonld['description'] );
		$this->assertArrayHasKey( 'estimatedCost', $how_to_jsonld );
		$this->assertEquals( '100 USD', $how_to_jsonld['estimatedCost'] );
		// 2 Tools should be present.
		$this->assertCount( 2, $how_to_jsonld['tool'] );
		$single_tool = $how_to_jsonld['tool'][0];
		$this->assertEquals( $single_tool['@type'], 'HowToTool' );
		$this->assertArrayHasKey( 'name', $single_tool );
		// Name should be tool 1.
		$this->assertEquals( $single_tool['name'], 'Tool 1' );

		// 2 Supply items should be present.
		$this->assertCount( 2, $how_to_jsonld['supply'] );
		$single_supply = $how_to_jsonld['supply'][0];
		$this->assertEquals( $single_supply['@type'], 'HowToSupply' );
		$this->assertArrayHasKey( 'name', $single_supply );
		// Name should be supply 1.
		$this->assertEquals( $single_supply['name'], 'Supply 1' );

		// 1 Step item should be present.
		$steps = $how_to_jsonld['step'];
		// 1 step should be present.
		$this->assertCount( 1, $how_to_jsonld['step'] );
		$single_step = $steps[0];
		// @type should be howtostep
		$this->assertEquals( 'HowToStep', $single_step['@type'] );
		// itemListElement should be present.
		$this->assertArrayHasKey( 'itemListElement', $single_step );
		// Step item should be one.
		$step_items = $single_step['itemListElement'];
		$this->assertCount( 1, $step_items );
		$single_step_item = $step_items[0];
		// A single step item should have type and text.
		$this->assertArrayHasKey( '@type', $single_step_item );
		$this->assertArrayHasKey( 'text', $single_step_item );
		// @type should be HowToDirection
		$this->assertEquals( 'HowToDirection', $single_step_item['@type'] );
		$this->assertEquals( 'Step Text', $single_step_item['text'] );
	}

	public function test_how_to_with_5_section() {
		// Create a post and assign it the How To category.
		$post_id  = $this->factory()->post->create();
		$result_1 = wp_add_object_terms( $post_id, 'how-to', 'category' );
		$max_steps = 5;
		for ( $i = 1; $i <= $max_steps; $i ++ ) {
			$result = add_row( 'step', array(
				'type' => 'HowToSection',
				'name'  => "Name $i",
				'section_item' => array(
					array(
						'step_name' => "Step Name $i",
						'step_text' => "Step Text $i",
					),
				),
			), $post_id );
			$this->assertNotFalse( $result, 'Must not be false.' );
		}


		$jsonlds = $this->jsonld_service->get_jsonld( false, $post_id );
		$mapping_converter_instance = new Wordlift_Mapping_Jsonld_Converter( $post_id, $jsonlds );

		$property_data_2 = array(
			'property_name'   => 'step',
			'field_type' => 'ACF',
			'field_name'      => 'step',
			'transform_function'  => 'how_to_step_transform_function',
			'property_status'      => Wordlift_Mapping_Validator::ACTIVE_CATEGORY,
		);
		$properties    = array(
			$property_data_2,
		);
		// Create a mapping item for category how_to.
		$this->create_new_mapping_item( 'category', (int) $result_1[0], $properties );

		$jsonlds = $mapping_converter_instance->get_jsonld_data();
		$jsonld  = end( $jsonlds );
		$single_step = $jsonld['step'][0];
		// Type of step should be HowToSection.
		$this->assertEquals( $single_step['@type'], 'HowToSection' );
		$this->assertArrayHasKey( 'itemListElement', $single_step );
		// A single step should have 1 section item in the array.
		$section_list = $single_step['itemListElement'];
		$this->assertCount( 1, $section_list );
	}


}
